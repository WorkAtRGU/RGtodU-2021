package uk.ac.rgu.rgtodu.data;

import android.content.Context;
import android.os.Handler;
import android.os.Looper;
import android.widget.TextView;

import androidx.lifecycle.LiveData;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Random;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

/**
 * This class provides the single point of truth in the app for {@link TaskRepository}s, and
 * will in the future deal with downloading, storing, and retrieving them.
 * @author  David Corsar
 */
public class TaskRepository {

    /**
     * Member field for database operations
     */

    private TaskDao taskDao;

    /**
     * A field for storing the tasks from the database
     */
    private LiveData<List<Task>> tasks;

    /**
     * A field for how dates should be formatted before displaying to users
     * with the day of the month as a number, and the month as text
     */
    private static final String DATE_FORMAT = "dd MMM";

    /**
     * The Singleton instance for this repository
     */
    private static TaskRepository INSTANCE;

    /**
     * The Context that the app is operating within
     */
    private Context context;

    /**
     * Create a new @{@link TaskRepository}
     * @param context The {@link Context} for the database to operate in
     */
    private TaskRepository(Context context){

        // setup for taskDao for accessing the database
        taskDao = TaskDatabase.getDatabase(context).taskDao();
        // get all of the tasks from the database using the taskDao
        tasks = taskDao.getAllTasks();
    }

    /**
     * Gets the singleton {@link TaskRepository} for use when managing {@link Task}s
     * in the app.
     * @return The {@link TaskRepository} to be used for managing {@link Task}s in the app.
     */
    public static TaskRepository getRepository(Context context){
        if (INSTANCE == null){
            synchronized (TaskRepository.class) {
                if (INSTANCE == null)
                    INSTANCE = new TaskRepository(context);
            }
        }
        return INSTANCE;
    }

    /**
     * Gets all the tasks in the database
     * @return a {@link LiveData} {@link List} of all the {@link Task} entities in the database
     */
    public LiveData<List<Task>> getAllTasks(){
        return this.tasks;
    }

    /**
     * Gets all the tasks in the database without using LiveData
     *
     * @return a {@link List} of all the {@link Task} entities in the database
     */
    public List<Task> getAllTasksNonlivedata(){
        return this.taskDao.getAllTasksNonlivedata();
    }

    /**
     * Stores task in the database
     * @param task The {@link Task} to store in the Room database.
     */
    public void storeTask(Task task){
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(new Runnable() {
            @Override
            public void run() {
                taskDao.insert(task);
            }
        });
    }


    /**
     * Stores the list of tasks in the database
     * @param tasks The {@link List} of {@link Task}s to store in the Room database.
     */
    public void storeTasks(List<Task> tasks){
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(new Runnable() {
            @Override
            public void run() {
                taskDao.insertTasks(tasks);
            }
        });
    }

    /**
     * Updates task in the database
     * @param task The {@link Task} to store in the Room database.
     */
    public void updateTask(Task task){
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(new Runnable() {
            @Override
            public void run() {
                taskDao.update(task);
            }
        });
    }

    /**
     * Stores the list of tasks in the database
     * @param tasks The {@link List} of {@link Task}s to store in the Room database.
     */
    public void updateTasks(List<Task> tasks){
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(new Runnable() {
            @Override
            public void run() {
                taskDao.updateTasks(tasks);
            }
        });
    }

    /**
     * Deletes task from the database
     * @param task The {@link Task} to delete from the Room database.
     */
    public void deleteTask(Task task){
        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(new Runnable() {
            @Override
            public void run() {
                taskDao.delete(task);
            }
        });
    }

    /**
     * Returns a list containing the specified number of Tasks generated by getTask
     * @param number The number of Tasks to return
     * @return
     */
    public List<Task> getSyntheticTasks(int number){
        List<Task> tasks = new ArrayList<>(number);
        for (int i = 0; i < number; i++){
            Task t = getSyntheticTask();
         
            tasks.add(t);
        }
        return tasks;
    }

    /**
     * Returns a {@link Task} with randomly generated info.
     * @return a {@link Task} for tomorrow, with randomly generated details.
     */
    public Task getSyntheticTask(){
        // create a new Task
        Task t = new Task();

        // A random number generator for populating the fields
        Random random = new Random();

        int id = random.nextInt(10000);
        // set the name randomly
        t.setName(String.format("Task %s", id));

        // set the description to some placeholder
        t.setDescription("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.");

        // set estimated hours to completely to be random between 1 and 5
        t.setHoursToCompletion(random.nextInt(5));

        // set the priority randomly
        t.setPriority(TaskPriority.values()[random.nextInt(3)]);

        // schedule it for up to 14 days in the future
        long offset = 1000*60*60*24 * random.nextInt(14);
        t.setDeadline(new Date(System.currentTimeMillis() + offset));

        return t;
    }


}
